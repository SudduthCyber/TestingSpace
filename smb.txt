import argparse
import struct
from impacket.smbconnection import SMBConnection
from impacket.dcerpc.v5 import samr, dtypes, lsad, lsat
from impacket.dcerpc.v5.dtypes import MAXIMUM_ALLOWED
from impacket.dcerpc.v5.rpcrt import DCERPCException

class SmbAcls:
    def __init__(self, server, share, username, password, domain="WORKGROUP"):
        self.server = server
        self.share = share
        self.username = username
        self.password = password
        self.domain = domain
        self.smb = None

    def connect(self):
        """ Establish SMB connection """
        try:
            self.smb = SMBConnection(self.server, self.server)
            self.smb.login(self.username, self.password, self.domain)
            print(f"Connected to {self.server} as {self.username}")
        except Exception as e:
            print(f"Failed to connect: {e}")
            exit(1)

    def get_acl(self, path):
        """ Fetch ACL information for a given file/folder """
        try:
            security_descriptor = self.smb.querySecurity(path, dtypes.OWNER_SECURITY_INFORMATION |
                                                         dtypes.GROUP_SECURITY_INFORMATION |
                                                         dtypes.DACL_SECURITY_INFORMATION)
            return self._parse_acl(security_descriptor)
        except DCERPCException as e:
            print(f"Error retrieving ACLs: {e}")
            return None

    def set_acl(self, path, sid, permissions, action="add"):
        """ Modify ACL: Add/Remove entries """
        try:
            security_descriptor = self.smb.querySecurity(path, dtypes.DACL_SECURITY_INFORMATION)
            dacl = self._modify_acl(security_descriptor, sid, permissions, action)
            self.smb.setSecurity(path, dtypes.DACL_SECURITY_INFORMATION, dacl)
            print(f"ACL {action}ed for {sid} with permissions {permissions}")
        except DCERPCException as e:
            print(f"Error modifying ACL: {e}")

    def _parse_acl(self, security_descriptor):
        """ Decode ACLs from security descriptor """
        if not security_descriptor:
            return "No ACL entries found."

        dacl_data = security_descriptor['Dacl']['Data']
        acl_entries = []

        offset = 0
        ace_count = struct.unpack('<H', dacl_data[2:4])[0]
        
        for _ in range(ace_count):
            ace_type = dacl_data[offset]
            access_mask = struct.unpack('<I', dacl_data[offset + 4:offset + 8])[0]
            sid = self._parse_sid(dacl_data[offset + 8:])
            acl_entries.append(f"{sid} - {access_mask}")
            offset += 12  # Approximate ACE entry length

        return acl_entries

    def _modify_acl(self, security_descriptor, sid, permissions, action):
        """ Modify ACL entry """
        dacl_data = security_descriptor['Dacl']['Data']
        new_ace = self._encode_ace(sid, permissions)

        if action == "add":
            return dacl_data + new_ace
        elif action == "remove":
            return dacl_data.replace(new_ace, b"")
        
        return dacl_data

    def _parse_sid(self, data):
        """ Convert binary SID to string """
        sub_auth_count = data[1]
        sid_str = f"S-{data[0]}"
        sid_str += f"-{struct.unpack('<I', data[2:6])[0]}"
        for i in range(sub_auth_count):
            sid_str += f"-{struct.unpack('<I', data[6 + (i * 4):10 + (i * 4)])[0]}"
        return sid_str

    def _encode_ace(self, sid, permissions):
        """ Encode ACE for adding new ACL """
        ace_type = 0x00  # Access Allowed ACE
        ace_flags = 0x00
        access_mask = struct.pack('<I', permissions)
        sid_bytes = self._sid_to_bytes(sid)

        return struct.pack('<BBHI', ace_type, ace_flags, len(sid_bytes) + 8, access_mask) + sid_bytes

    def _sid_to_bytes(self, sid):
        """ Convert string SID to binary format """
        parts = sid.split('-')
        revision = int(parts[1])
        identifier = struct.pack('<I', int(parts[2]))
        sub_authorities = [struct.pack('<I', int(x)) for x in parts[3:]]

        return bytes([revision, len(sub_authorities)]) + identifier + b''.join(sub_authorities)

    def close(self):
        """ Close SMB session """
        if self.smb:
            self.smb.logoff()
            print("Disconnected from SMB.")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Python SMB ACLs management with Impacket")
    parser.add_argument("server", help="SMB Server")
    parser.add_argument("share", help="SMB Share")
    parser.add_argument("username", help="Username")
    parser.add_argument("password", help="Password")
    parser.add_argument("path", help="File/Folder path in share")
    parser.add_argument("--get", action="store_true", help="Get ACLs")
    parser.add_argument("--set", nargs=2, metavar=('SID', 'PERMISSIONS'), help="Set ACL")
    parser.add_argument("--remove", metavar='SID', help="Remove ACL for SID")

    args = parser.parse_args()
    smb_acls = SmbAcls(args.server, args.share, args.username, args.password)
    
    try:
        smb_acls.connect()

        if args.get:
            print("ACLs:", smb_acls.get_acl(args.path))
        
        if args.set:
            sid, perms = args.set
            smb_acls.set_acl(args.path, sid, int(perms), "add")

        if args.remove:
            smb_acls.set_acl(args.path, args.remove, 0, "remove")

    finally:
        smb_acls.close()
